<h1 class='article__header'>Some real initial stuff</h1>
<div class='article__prelude'>
    <p>Well... на протяжении 2 недель я боролся с корректной реализацией постов... боролся unsuccessfully. Проблема с отображением
    code samples с отступами, подсветкой синтаксиса и прочими мелочами, из-за которых, unfortunately, я не могу толком сдвинуться
    с места. В данный момент весь post's content лежит в JSON => оттуда я его достаю с помощью angular's service => затем он
    попадает в angular's controller => и уже там с помощью angular's scope я использую content непосредственно в постах. С текстом,
    датами, цифрами, чем угодно это срабатывает на ура ибо ничего сложного тут нет. Но code samples...</p>
    <p>Я не представляю как хранить примеры кода так, чтобы на выходе в постах я получал что-то похожее на code sample. Я хочу
    добиться подобного результата:</p>

<div hljs include="'compile1'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile1">
function hasDuplicates(array) {
    // some comments here
    for (var i = 0; i < array.length; i++)
        for (var j = i + 1; j < array.length; j++)
            if (array[i] == array[j]) return true;
    return false;
}
</script>
    <p>Естественно, все эти графические преобразования должны происходить автоматически, моя страничка должна получать дефолтным
    образом некие строки и парсить их в такой вот симпатичный code sample. Данный пример я написал руками, т.е. естественно
    строчки разукрашены с помощью специальной angular's directive, но сами strings написаны by myself, а не получены и распарсены
    из JSON. На stackoverflow мне предложили использовать Markdown => я установил => попробовал, но никаких дивидендов он мне не
    принёс. Maybe I just don't know how to use it right.</p>
    <p>So... эта страница обещает быть длинной :D By the way, я не верю в чудеса, но если на мой фантастический сайт occasionally
    попадёт знаток Angular.js и, in particular, размещения примеров кода на страницах сайта... напиши мне
    <a href='https://vk.com/forestalled' class='article__link'>vk</a> или на <span class='article__link'>impregnablefiend@gmail.com</span> и поделись опытом :)
    Я знаю - ты существуешь :)</p>
    <p>Изначально я планировал этот сайт как некий сборник всех моих (незначительных) знаний по программированию, I'm just
    learning и узнавая что-то новое я постоянно пишу это в тетрадь, на листочек или же храню в закладках. My goal в том, чтобы
    систематизировать и упорядочить эти знания. Until I dunno how to perform that lovely and correctly => я решил начать
    писать какие-то базовые вещи здесь, на этом одном превосходном роуте. Anyway, сайт мой - делаю, что хочу :) </p>
</div>
<div class='article__subtitle'>A few words about JavaScript</div>
<div>
    <div>Статья в очередной раз 'встала' due to <a ui-sref='postsAboutHilariousStuff({hilariousStuffPostId: 0})' class='article__link'>dat tragic accident.</a></div>
</div>
<div class='article__prelude'>
    <p>- - - - -</p>
    <p>Okay, <span class='article__link'>31 декабря 2016 года</span>, я наконец освободился и решил написать пару фраз :D. Насыщенный получился год, я менял жильё, работу, евро, моральные ценности, женщин, побывал на операции, на 'родине', встретился со старыми товарищами, много нового увидел и, к счастью, узнал.
    Не уверен, что я стал умнее мудрее взрослее или компетентнее, но надеюсь, что да. Однако сейчас не об этом.
    </p>
    <p>Пора начинать немного структурировать знания, которые у меня накопились за полтора года программирования, безумно хочется иметь свой 'гугл', куда можно обратиться.
     So... If you were waiting for the opportune moment, that was it. (цэ Jack S.)
    </p>
    <p>На самом деле, момент нихрена не подходящий, я сижу втроём (с джином и тоником) в преддверии НГ и готовлюсь смотреть блистательного Брюса в эпичнейшем фильме Die Hard, но почему-то именно сейчас
    мне пришло в голову открыть WebStorm и немного попечатать. Выкладывать я буду не рандомные вещи, а то с чем мне уже приходилось сталкиваться, объяснять самые банальные примеры я не буду, ибо не буду.
    Постараюсь выкладывать что-то на дефолтные темы, но конкретные примеры будут приближенными к реальности.
    </p>
    <h4>Vanilla/methods/replace</h4>
<div hljs include="'compile2'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile2">
function replaceSomething(yourGorgeousName) {
    return {
        name : yourGorgeousName,
        id : 'xxxxxxxxxx'.replace(
            /x/g, () => {
                let randomNumber = Math.random() * 16 | 0;
                return randomNumber.toString(16);
            }
        )
    }
}
console.log(replaceSomething('Артём')); // Object {name: "Артём", id: "97eb79feb2"}
</script>
    <p>Функция, в которую ты передаёшь своё имя и которая возвращает тебе объект с двумя парами key -> value, в первой собственно то самое имя (вау, вот это код!),
    во второй рандомный айдишник. Буковки 'x' заменяются на рандомные значения из шестнадцатеричной системы счисления. That's it.
    </p>
    <h4>#es6 #map #join #Object.keys</h4>
<div hljs include="'compile3'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile3">
let obj = {drink: 'gin', brand: 'beefeater'};

let result = Object.keys(obj)
    .map(key => key + '=' + (obj[key]))
    .join('&');

console.log(result); // drink=gin&brand=beefeater
</script>
    <p>На простом примере преобразования object -> query string показываю сразу несколько фич. Object.keys берёт объект и делает из него массив ключей этого объекта.
    Затем метод map трансформирует этот массив (создаёт новый!), между ключами и значениями ставится знак равенства (in my case).
    И наконец метод join берет этот новый массив и преобразует его в строку, между элементами ставится амперсанд. Here you go.
    </p>
    <p>- - - - -</p>
    <p>Well... <span class='article__link'>2 января 2017</span>, я вновь добираюсь до WebStorm'a. Близкий друг, увидев мои предыдущие примеры с переменной let, заинтересовался данным обстоятельством и полез гуглить 'wtf is let'.
    Узнав это я решил написать про let и const. Frankly, на самом деле уже 3 января, глубокая ночь и я только-только полчаса как пишу, так как обдумывая написание примеров по этой теме, я вспомнил безумно крутой фильм Pulp Fiction, и конкретную ситуацию в нём где Vincent рассказывает о 'the little differences' между Америкой и Европой. Собственно фраза Jules'а 'Examples?' и прозвучала в моей голове когда я начал печатать первый пример о let :)
    Btw, чертовски оригинальный и смотрибельный фильм, сколько раз уже видел его, да и вообще знаю 'by heart', но вот опять затянул. Okay...
    </p>
    <h4>#es6 #let #const #var #vanilla #hoisting</h4>
    <p>Попытаюсь объяснить очень кратко и четко, буквально в двух словах:</p>
    <ul>
        <li>Const и let существуют только внутри своего block scope. Как мы знаем, var существует внутри функции (function scope);</li>
        <li>You can declare const/let inside of it's (block) scope once. При попытке объявить еще раз браузер начнёт ругаться;</li>
        <li>However, const can not be updated, while let can. Собственно, в этом суть переменной let. Она может быть изменена сотню раз если например используется как счётчик цикла;</li>
        <li>Next, let, в отличие от var, не существует до объявления. For example:
        <div hljs include="'compile4'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile4">
function letBehavior() {
    console.log(number); // Oops! Uncaught ReferenceError: number is not defined
    let number = 11;
}
letBehavior();
</script>
       Отладчик говорит, что я сошел с ума и прошу невозможного, так как никакой переменной number еще не существует. Та же ситуация с var:
        <div hljs include="'compile5'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile5">
(function varBehavior() {
    console.log(number, 'firstCase'); // it's undefined yet
    var number = 11;
    console.log(number, 'secondCase'); // while this is already 11
})();
</script>
        Здесь я немного усложнил задачу, чтобы между делом показать еще и такую забавную штуку как hoisting. В консоль выведется разная информация, так как хоть var и существует до объявления, но никакого определенного значения конечно же еще не имеет и, следовательно,
        в первом случае выведется undefined и лишь во втором число 11. Что на самом деле происходит в коде в это время:
        <div hljs include="'compile6'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile6">
function varBehavior() {
    var number;
    console.log(number, 'firstCase');
    number = 11;
    console.log(number, 'secondCase');
}
varBehavior();
</script>
        So... тут всё понятно, но я немного отвлёкся от let и const. Впрочем, я до сих пор не сказал разве что про 'иммутабельность' const.
        </li>
        <li>Некоторым кажется, что const - это вроде как абсолютная константа и в принципе не может быть изменена. Но конечно же если мы имеем дело с объектом, объявленным через const, то мы можем при желании изменить его свойства:
        <div hljs include="'compile7'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile7">
const car = {
    brand: 'Nissan',
    color: 'blue'
}
car.color = 'red';
console.log(car); // Object {brand: "Nissan", color: "red"}
</script>
            Why not? :)
        </li>
    </ul>
    <p>Слов получилось больше чем я ожидал, а примеров маловато, если irl встретится что-то интересное с let, то обязательно напишу. А теперь status-add-commit-push и спать...
    </p>
    <p>- - - - </p>
    <p>Итак, ночь <span class='article__link'>с 3 на 4 января</span> и я снова тут. Two days in a row, wow!... Во-первых, немного поправил вчерашние примеры чтобы они стали чуть более понятны. Во-вторых, подумал, что стоит написать реальный пример использования let с целью объяснить чем же он всё-таки круче/хуже var.
    Стоит признать для человека с моим lvl'ом довольно сложная задача придумать самому from scratch реальный пример на эту тему и, да, я с ней не справился. Однако я знаю один довольно популярный пример, который очень любят рассказывать программеры когда поднимается этот вопрос. Для того чтобы удовлетворить собеседующего при устройстве на толковую работу думаю будет вполне достаточно :)
    </p>
    <p>So, всеми любимый цикл, внутри находится click handler, установленный на нескольких div'ах на которых просто написаны цифры по порядку. Что мы ожидаем от этого феноменального кода? Что при клике на любое число (div'а с числом) нам в консоль выведется именно это число. Именно так и произойдёт если я воспользуюсь переменной let. Но если я напишу var, то произойдёт странная вещь. Во всяком случае для меня еще полгода назад она была странной. Собственно код:
    </p>
    <div hljs include="'compile8'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile8">
// рисуем два div'а с айдишниками 1_el и 2_el
// и, собственно, JS:
for (let i = 1; i <= 2; i++) {
    document.getElementById(`${i}_el`)
        .addEventListener('click', () => console.log(i))
}
</script>
    <p>Всё работает как часы, все счастливы и уже охлаждают шампанское, а потом для интереса вместо let пишут var и видят в консоли число 3. What the deuce? (цэ Stewie G.)
    </p>
    <p>В самом первом пункте объяснения let-const-var я написал, что let существует только в своём block scope. Это значит, что на каждой итерации объявление let i создаёт свою переменную, => никаких проблем с таким кодом нет и быть не может.</p>
    <p>Возникает вопрос - что происходит когда мы используем var? Попытаюсь объяснить это человеческим языком :) К тому времени как человек нажимает на любой из div'ов по меркам программирования проходит уже миллион лет (образно) и в замыкании click handler'а давным-давно хранится единственная (!) ссылка (reference) на i,
    которая является последним числом, которое смог вывести цикл - в данном случае 3. Чтобы избежать этого приходится плясать с бубном и писать дополнительный код, о котором, как и о замыканиях в принципе я напишу чуть позже. В случае с let такой проблемы нет.
    Nuff said.</p>
    <p>- - - - -</p>
    <p>Hii... <span class='article__link'>6 января 2017 :)</span> и я с чаем и приподнятым настроением вновь пишу. Для начала миниатюрный красивый пример с indexOf. Допустим, у нас имеется большой список файлов, разделенных на определенные категории, у каждой категории начало наименования совпадает. Требуется создать несколько списков, распределенных по категориям. Используем indexOf в функции, которая возвращает boolean.</p>
    <h4>Vanilla/methods/indexOf</h4>
    <div hljs include="'compile9'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile9">
function startsWith(file, name) {
    return file.indexOf(name) == 0;
}
// теперь если у нас под рукой есть angular.js, то мы всегда можем написать что-то вроде
li ng-repeat='file in files' ng-show="startsWith(file, 'vanilla')"
    // ...
/li
</script>
    <p>Если хоть одно название файла будет начинаться с 'vanilla' - он будет виден в этом списке, а остальные не будут.</p>
    <p>All right, сегодня я хотел продолжить прошлую тему и рассказать немного о замыканиях. Так, как я их понимаю :)</p>
    <h4>#closures #vanilla #interestingStuff #selfEducation</h4>
    <p>Сначала немного теории... Как мы все понимаем далеко не всегда в функции есть все переменные, которые в ней используются. В программировании есть такое красивое слово как лексическое окружение. Бывают случаи (очень часто), что в функции присутствуют переменные, которые определены во внешнем lexical environment. Интерпретатор сначала проверяет текущий скоуп функции на наличие искомой переменной, потом внешний, может быть потом следующий внешний, и так до тех пор пока не дойдёт до window. So, в двух словах, замыкание - это некая функция и внешние переменные, которые ей доступны. Пример:</p>
    <div hljs include="'compile10'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile10">
function favoriteDrink() {
    var favoriteDrink = 'whiskey';

    return {
        getDrink: function() {
            return favoriteDrink;
        },
        setDrink: function(newFavoriteDrink) {
            favoriteDrink = newFavoriteDrink;
        }
    }
}

var drink = favoriteDrink();
console.log(drink.getDrink()); // whiskey
console.log(drink.setDrink('gin')); // undefined
console.log(drink.getDrink()); // gin
</script>
    <p>Здесь я показал JavaScript-way создания приватных переменных. Я создал variable favoriteDrink, но использовал только ссылку на неё в последующих методах (на данный момент я это так понимаю, через n-ое количество времени надо будет пере/дописать... а может и окажется, что я absolutely right) =)</p>
    <p>Btw, конкретно в JS, в отличие от многих других языков, замыканием функции часто называют только внешние переменные. А в моём примере можно сказать 'переменная favoriteDrink в методе getDrink берётся из замыкания (читай - внешнего лексического окружения)'.</p>
    <p>В этих ваших интернетах я однажды наткнулся на очень хорошую статью одной умной девочки, которая написала свой пример на эту же тему, написав что-то вроде 'look how we can maintain a private reference to a variable in the outer scope'. И там было нечто подобное:</p>
    <div hljs include="'compile11'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile11">
function password() {
    var password = 'yourSophisticatedPassword';

    return {
        guessPassword: function(guess) {
            if (guess === password) {
                return true;
            } else {
                return false;
            }
        }
    }
}
var attempt = password();
attempt.guessPassword('IAmHacker!'); // false
attempt.guessPassword('yourSophisticatedPassword'); // true
</script>
    <p>Собственно здесь показано, что у функции-замыкания guessPassword есть доступ к переменной, объявленной в 'вышестоящем' скоупе, а у 'остальных' этого самого аксэсса нет. По-моему очень элегантное и простое, а главное понятное, решение... Надеюсь я тоже скоро начну писать такие красивые примеры в тему :)</p>
    <p>Finally... в прошлый раз я обещал объяснить как оживить тот самый пример про let-var и click handler, чтобы он правильно работал не только с let, но и с var. Показываю:</p>
    <div hljs include="'compile12'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile12">
for (var i = 1; i <= 2; i++) {
    document.getElementById(`${i}_el`)
        .addEventListener('click',
        // далее мы писали () => console.log(i), now we go like:
        (function(j) {
            return function() {
                console.log(j);
            }
        }(i))
        // we wrap it in an anonymous function and pass i as argument
)}
</script>
    <p>Еще раз объясняю, только немного другими словами: если не обернуть console.log(i) анонимной функцией и не передать счётчик цикла как аргумент, то замыкание ('() => console.log(i)' - вот это всё и является замыканием) будет иметь доступ к переменной i из внешнего лексического окружения по ссылке, а не по значению. А в этом самой ссылке давно лежит цифра 3, так как цикл тысячу лет назад отработал. Чтобы исправить это недоразумение я, повторюсь, обернул функцию в анонимную функцию и передал i в качестве аргумента. Такой метод решения подобных 'багов' замыканий называется Immediately Invoked Function Expression.</p>
    <p>Well... <span class='article__link'>воскресенье, 5 февраля 2017</span> и я наконец нахожу в себе силы продолжить общение с воображаемым читателем :) Последние пару недель были психологически тяжелыми... даже не хочу ничего писать на эту тему. So! Начну с небольшого странного примера непосредственно который никогда не пригодится irl, но моему товарищу его задали на собеседовании, и по-моему я нашел максимально краткое и корректное решение. Задача звучит так: написать функцию на JS, которая будет принимать строку и возвращать эту же строку, но чтобы последняя буква становилась заглавной. Мой код:</p>
    <h4>Vanilla/methods/slice</h4>
    <div hljs include="'compile13'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile13">
function magic(s) {
    return s.slice(0, -1) + s.slice(-1).toUpperCase();
}

console.log(magic('Артём Артём')); // Артём АртёМ
</script>
    <p>Работает как с зарубежными буковками, так и с русскими, что немаловажно, так как насколько я понимаю использование RegExp'ов вместе с replace даст результат только для латиницы. (если я ошибаюсь - let me know =) )</p>
    <p>Next... уже очень давно я хотел начать писать и параллельно разбираться с промисами, колбэками и прочими важнейшими составляющими JS. Без них не проходит ни одно толковое собеседование фронтэндера. Кстати о собеседованиях... в своих кратких рассуждениях я еще не упоминал o typeof... при устройстве на работу всегда можно получить крайне простой вопрос, который может мгновенно поставить в тупик :) Например:</p>
    <h4>Vanilla/operators/typeof</h4>
    <div hljs include="'compile14'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile14">
// что мы увидим в консоли после выполнения?
let array = ['some', 'strings', 7];
typeof (typeof array);
</script>
    <p>Правильный и подробный ответ возвращает (или отправляет, idk) нас к истокам изучения JS. Какие существуют типы данных и сколько их в JavaScript? Очевидно, что шесть, и такого типа как массив в JS нет, так что в правой части выражения нам вернётся "object". А typeof "object" разумеется вернёт "string". Если же не вдаваться в детали, то ответ 'операнд typeof всегда возвращает строку, которая содержит тип операнда' будет вполне приемлем.</p>
    <p>Right... а теперь вернёмся к нашим, гм, колбэкам. <span class='article__link'>Ночь с 6 на 7 февраля подкралась незаметно</span> - Артём снова тут :)</p>
    <h4>#callback #vanilla #uCan'tCallUrselfProgrammerIfUDoNotEvenKnowThat</h4>
    <p>Callback - так разработчики именуют любую функцию, которая передана в другую функцию в качестве аргумента. Simple concept, wright? Главный вопрос - для чего нужен callback и в каких ситуациях стоит его использовать? Есть несколько причин. Понимаю я все (so-so), но right now толковым примером смогу объяснить только одну. Вот он:</p>
    <div hljs include="'compile15'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile15">
// пишем одну(!) функцию, которая принимает массив чисел и callback, который пока неизвестен
function base(array, cb) {
    var newArray = [];
    for (var i = 0; i < array.length; i++) {
        newArray[i] = cb(array[i]);
    }
    return newArray;
}

// массив чисел над которым будут проводиться операции, в этом примере я его задал сам
// числа могут вводиться пользователем (если вы пишите, например, калькулятор)
var array = [1,3,5,10];

// а вот и непосредственно сами операции (возведение в квадрат, куб, wateva...)
var doSquare = base(array, (x) => x * x);
var doCube = base(array, (x) => x * x * x);
// операции по-хорошему надо выносить в отдельные функции (инкапсулировать), но здесь это необязательно :)

console.log(doSquare); // [1, 9, 25, 100]
console.log(doCube);   // [1, 27, 125, 1000]
</script>
    <p>По-моему, комментарии тут излишни. Завтра попытаюсь написать внятный пример cb на тему асинхронности (собственно главную тему cb).</p>
    <p>Well... моё 'завтра' оказалось на полтора месяца позже чем я рассчитывал. Такой себе результат, right. But, you know, лучше поздно чем никогда :) That's why I'm here, if you follow me... So! :D Time to keep going, i mean writing :)</p>
    <p>И да, сейчас <span class='article__link'>21 апреля.</span></p>
    <p>Как всегда много чего успело произойти, но сейчас не об этом. Факт в том, что в июне у меня заканчивается контракт и я буду перебираться в другое место... вариант с остаться пока что тоже рассматривается, но это вряд ли. Так вот... уже сегодня у меня первое собеседование (которых у меня год не было) и я решил немного повторить всё, что я знаю :) Собственно это первое интервью куда я пойду практически без подготовки. Не уверен, что это верное решение, но вот как-то так.</p>
    <p>Сижу листаю свои старые записи, уже мысленно прикидываю как можно переписать какой-нибудь уже устаревший метод решения задачки с помощью того же es6. По традиции, пример:</p>
    <h4>#usingCuteMethodsToSolveDefaultTasks #arrays</h4>
    <div hljs include="'compile16'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile16">
function reverseArray(arr) {
    return arr.map((item, i) => arr[arr.length-1-i]);
}
</script>
    <p>Взяли и перевернули массив безо всяких for-ов, swap-ов и прочих 'страшных' вещей :) Meanwhile на одну своеобразную задачку наткнулся... если не ошибаюсь мне её с полгода назад друг задавал... на первый взгляд проще ничего не придумать, а с другой стороны идеальная проверка на знание стоковых методов, функций, да и вообще всего базового :) В общем, есть переменная (integer), которую нужно превратить в int равный сумме всех цифр исходного числа :) То есть из 15 получить 6, а 39 преобразовать в 12 :)</p>
    <h4>#toString() #split #map #reduce</h4>
    <div hljs include="'compile17'" compile='true' language='javascript'></div>
<script type="text/ng-template" id="compile17">
function numToSum(num) {
    return num.toString().split('').map(Number).reduce((a, b) => a + b);
}
</script>
    <p>That's it... ладно пойду я всё-таки прочту что-нибудь полезное :) А затем спать-спать... под Slipknot :) А вернусь завтра... правда завтра :)</p>
    <p>Well... <span class='article__link'>14 июня 2017</span> и я снова тут. Вновь не 'завтра', но на то есть и были очень веские причины. Точнее причина. Она. Но сейчас не об этом. Я, как и планировал, по окончании контракта ухожу с текущей работы (30 июня) и перебираюсь на новое место. Какое? Пока неизвестно. Завтра 2 собеседования, послезавтра 2... it's gonna be fun.</p>
    <p><span class='article__link'>6 июля 2017</span> вышел на новую работу, писать буду теперь <a ui-sref='secondInfoPage' class='article__link'>где-то тут.</a></p>
</div>